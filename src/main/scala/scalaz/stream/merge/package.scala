package scalaz.stream

import scalaz.Ordering.{GT, LT, EQ}
import scalaz.\&/.{That, This, Both}
import scalaz.{\&/, Order}
import scalaz.concurrent.{Strategy, Task}


package object merge {


  /**
   * Merges non-deterministically processes that are output of the `source` process.
   *
   * Merging stops when all processes generated by source have stopped, and all source process stopped as well.
   * Merging will also stop when resulting process terminated. In that case the cleanup of all `source`
   * processes is run, followed by cleanup of resulting process.
   *
   * When one of the source processes fails the mergeN process will fail with that reason.
   *
   * Merging is non-deterministic, but is fair in sense that every process is consulted, once it has `A` ready.
   * That means processes that are `faster` provide it's `A` more often than slower processes.
   *
   * Internally mergeN keeps small buffer that reads ahead up to `n` values of `A` where `n` equals to number
   * of active source streams. That does not mean that every `source` process is consulted in this read-ahead
   * cache, it just tries to be as much fair as possible when processes provide their `A` on almost the same speed.
   *
   */
  def mergeN[A](source: Process[Task, Process[Task, A]])(implicit S: Strategy): Process[Task, A] =
    scalaz.stream.nondeterminism.njoin(0, 0)(source)(S)

  /**
   * MergeN variant, that allows to specify maximum of open `source` processes.
   * If, the maxOpen is <= 0 it acts like standard mergeN, where the number of processes open is not limited.
   * However, when the maxOpen > 0, then at any time only `maxOpen` processes will be running at any time
   *
   * This allows for limiting the eventual concurrent processing of opened streams not only by supplied strategy,
   * but also by providing a `maxOpen` value.
   *
   *
   * @param maxOpen   Max number of open (running) processes at a time
   * @param source    source of processes to merge
   */
  def mergeN[A](maxOpen: Int)(source: Process[Task, Process[Task, A]])(implicit S: Strategy): Process[Task, A] =
    scalaz.stream.nondeterminism.njoin(maxOpen, maxOpen)(source)(S)

  /**
    * Merge two source processes, `leftSource` and `rightSource`, that are ALREADY SORTED by distinct key `A`,
    * and produce an output process, which will also be sorted by `A`.
    *
    * If a key is only present in the `leftSource`, the output for this key will be a `This` containing the value from
    * the `leftSource`. If a key is only present in the 'rightSource`, the output for this key will be a `That`
    * containing the value from the `rightSource`. If a key is present in both, the output for this key will be a
    * `Both`, containing values from both sources.
    *
    * @param sourceLeft
    * @param sourceRight
    * @param fa
    * @param fb
    */
  def mergeSorted[F[_], L, R, A: Order](sourceLeft: Process[F, L], fa: L => A)(sourceRight: Process[F, R], fb: R => A): Process[F, L \&/ R] = {
    def next(l: L, r: R): Tee[L, R, L \&/ R] =
      Order[A].order(fa(l), fb(r)) match {
        case EQ => Process.emit(Both(l, r)) ++ nextLR
        case LT => Process.emit(This(l)) ++ nextL(r)
        case GT => Process.emit(That(r)) ++ nextR(l)
      }

    def passL: Tee[L, R, L \&/ R] = tee.passL map This.apply
    def passR: Tee[L, R, L \&/ R] = tee.passR map That.apply

    def nextL(r: R): Tee[L, R, L \&/ R] =
      tee.receiveLOr[L, R, L \&/ R](Process.emit(That(r)) ++ passR)(next(_, r))
    def nextR(l: L): Tee[L, R, L \&/ R] =
      tee.receiveROr[L, R, L \&/ R](Process.emit(This(l)) ++ passL)(next(l, _))
    def nextLR: Tee[L, R, L \&/ R] =
      tee.receiveLOr(passR)(nextR)

    sourceLeft.tee(sourceRight)(nextLR)
  }

}
