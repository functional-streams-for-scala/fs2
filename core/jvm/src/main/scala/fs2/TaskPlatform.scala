package fs2

import scala.concurrent.SyncVar
import scala.concurrent.duration._

import java.util.concurrent.atomic.AtomicBoolean

import fs2.util.Attempt

private[fs2] trait TaskPlatform {

  implicit class JvmSyntax[A](val self: Task[A]) {

    /**
     * Run this `Task` and block until its result is available. This will
     * throw any exceptions generated by the `Task`. To return exceptions
     * in an `Either`, use `unsafeAttemptRun()`.
     */
    def unsafeRun(): A = unsafeAttemptRun().fold(t => throw t, identity)

    /** Like `unsafeRun`, but returns exceptions as values. */
    def unsafeAttemptRun(): Either[Throwable,A] =
      self.unsafeAttemptRunSync() match {
        case Right(result) => result
        case Left(cont) =>
          val latch = new java.util.concurrent.CountDownLatch(1)
          @volatile var result: Option[Attempt[A]] = None
          cont { attempt => result = Some(attempt); latch.countDown }
          latch.await
          result.get
      }

    /**
     * Run this `Task` and block until its result is available, or until
     * `timeout` has elapsed, at which point a `TimeoutException`
     * will be thrown and the `Future` will attempt to be canceled.
     */
    def unsafeRunFor(timeout: FiniteDuration): A = unsafeAttemptRunFor(timeout) match {
      case Left(e) => throw e
      case Right(a) => a
    }

    /**
     * Like `unsafeRunFor`, but returns exceptions as values. Both `TimeoutException`
     * and other exceptions will be folded into the same `Throwable`.
     */
    def unsafeAttemptRunFor(timeout: FiniteDuration): Either[Throwable,A] = {
      val sync = new SyncVar[Attempt[A]]
      val interrupt = new AtomicBoolean(false)
      self.unsafeRunAsyncInterruptibly(sync.put, interrupt)
      sync.get(timeout.toMillis).getOrElse {
        interrupt.set(true)
        Left(Task.timeoutException(timeout))
      }
    }
  }
}
